package com.agileasoft.jackcess.orm.mapper;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityExistsException;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

import org.apache.commons.lang.WordUtils;

import com.healthmarketscience.jackcess.JackcessException;
import com.healthmarketscience.jackcess.Row;

public class AccessMapper<E> {
	private String _tableName;
	final private Map<String, String> _mapColumnsJavaKey = new HashMap<String, String>();
	final private Map<String, String> _mapColumnsDbKey = new HashMap<String, String>(); 
	final private Map<String, String> _mapFieldsType = new HashMap<String, String>();
	private boolean _hasId = false;
	private boolean _isIdAutoGenerated = false;
	private String _attributeIdName;
	Class<E> clazz;
	
	public AccessMapper(Class<E> clazz) {
		this.clazz = clazz;
		Entity entityAnnotation = clazz.getAnnotation(Entity.class);
		if(entityAnnotation == null) {
			throw new EntityExistsException("this POJO is not an Entity, @Entity must be added.");
		}
		Table tableAnnotation = clazz.getAnnotation(Table.class);
		if(tableAnnotation != null) {
			_tableName = tableAnnotation.name();
		}
		if(_tableName == null || "".equals(_tableName)) {
			_tableName = camelcaseToUnderscore(clazz.getSimpleName());
		}
		
		Field[] fields = clazz.getDeclaredFields();
		for(Field field : fields) {
			_mapFieldsType.put(field.getName(), field.getType().getCanonicalName());
			Column columnAnnotation = field.getAnnotation(Column.class);
			if(columnAnnotation != null) {
				String dbColumnName = columnAnnotation.name();
				if(dbColumnName == null || "".equals(dbColumnName)) {
					dbColumnName = camelcaseToUnderscore(field.getName());
				}
				_mapColumnsJavaKey.put(field.getName(), dbColumnName);
				_mapColumnsDbKey.put(dbColumnName, field.getName());
			}
			
			// check for Id
			Id idAnnotation = field.getAnnotation(Id.class);
			if(idAnnotation != null) {
				_hasId = true;
				_attributeIdName = field.getName();
				GeneratedValue genValAnnotation = field.getAnnotation(GeneratedValue.class);
				if(genValAnnotation != null) {
					_isIdAutoGenerated = true;
				}
			}
		}
	}
	
	public String getEntityAttribute(String dbColumn) {
		return _mapColumnsDbKey.get(dbColumn);
	}
	
	public String getDbColumn(String javaAttribute) {
		return _mapColumnsJavaKey.get(javaAttribute);
	}
	
	public String getTableName() {
		return _tableName;
	}
	
	public Object getId(E entity) throws JackcessException  {
		try {
			final String getterMethodName = "get" + WordUtils.capitalize(_attributeIdName);
			return clazz.getDeclaredMethod(getterMethodName).invoke(entity);
		} catch (Exception e) {
			throw new JackcessException(e);
		}
	}
	
	public boolean hasId() {
		return _hasId;
	}
	
	public String getAttributeIdName () {
		return _attributeIdName;
	}
	
	public E getMappedObject(Row row) throws JackcessException {
		try {
			E entity = clazz.newInstance();
			for (String col : _mapColumnsDbKey.keySet()) {
	        		final String javaAttributeName = _mapColumnsDbKey.get(col);
	                final String setterMethodName = "set" + WordUtils.capitalize(javaAttributeName);
	                final Class<?> paramType = Class.forName(_mapFieldsType.get(javaAttributeName));
	                entity.getClass().getDeclaredMethod(setterMethodName, paramType).invoke(entity, row.get(col));
	        }
			return entity;
		} catch (Exception e) {
			throw new JackcessException(e);
		}
    }
	
	public Map<String, Object> getMappedRow(E entity, boolean isForInsert) throws JackcessException {
		try {
			Map<String, Object> map = new HashMap<String, Object>();
			for (String attribute : _mapColumnsJavaKey.keySet()) {
				if(isForInsert && _hasId && attribute.equals(_attributeIdName)) {
					if(_isIdAutoGenerated) {
						continue;
					}
				}
					final String dbColumnName = _mapColumnsJavaKey.get(attribute);
					final String getterMethodName = "get" + WordUtils.capitalize(attribute);
					final Object value = entity.getClass().getDeclaredMethod(getterMethodName).invoke(entity);
					map.put(dbColumnName, value);
				
			}
			return map;
		} catch (Exception e) {
			throw new JackcessException(e);
		}
	}
	
	private String camelcaseToUnderscore (String value) {
		if(value == null) return null;
		String regex = "([a-z])([A-Z])+";
        String replacement = "$1_$2";
        return value.replaceAll(regex, replacement).toUpperCase();
	}
}
